<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', -apple-system, sans-serif;
            background: #000;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #canvas {
            display: block;
            background: #000;
        }

        /* Control Panel */
        .controls {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 18px;
            color: #fff;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.15);
            min-width: 280px;
        }

        .controls h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #00ff88;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 10px;
        }

        .control-row label {
            font-size: 12px;
            color: #aaa;
            min-width: 70px;
        }

        .control-row select,
        .control-row input[type="range"] {
            flex: 1;
        }

        select {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
            outline: none;
        }
        select option { background: #111; }

        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }

        .value-label {
            font-size: 12px;
            color: #00ff88;
            min-width: 50px;
            text-align: right;
        }

        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-start {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
        }
        .btn-start:hover { transform: scale(1.02); }
        .btn-start:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
        .btn-stop {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
        }
        .btn-shuffle {
            background: rgba(255,255,255,0.15);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .btn-shuffle:hover { background: rgba(255,255,255,0.25); }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        .checkbox-row input { width: 16px; height: 16px; cursor: pointer; }
        .checkbox-row label { font-size: 12px; color: #aaa; cursor: pointer; }

        /* Stats Panel */
        .stats {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 18px;
            color: #fff;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.15);
            min-width: 180px;
        }

        .stats h3 {
            font-size: 14px;
            color: #00ff88;
            margin-bottom: 12px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .stat-item .label { color: #888; }
        .stat-item .value { color: #fff; font-weight: 600; }

        /* Character */
        .character {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 50;
            pointer-events: none;
            transition: transform 0.3s ease;
        }
        .character img {
            max-height: 200px;
            filter: drop-shadow(0 0 20px rgba(0,255,136,0.3));
        }
        .character.excited img {
            animation: bounce 0.3s ease infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Algorithm Info */
        .algo-info {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 20px;
            color: #fff;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.15);
        }
        .algo-info h4 {
            font-size: 14px;
            color: #00ff88;
            margin-bottom: 8px;
        }
        .algo-info p {
            font-size: 12px;
            color: #888;
            line-height: 1.5;
        }
        .algo-info .complexity {
            display: flex;
            gap: 15px;
            margin-top: 8px;
        }
        .algo-info .complexity span {
            font-size: 11px;
            color: #aaa;
        }
        .algo-info .complexity strong {
            color: #fff;
        }

        /* Progress bar */
        .progress-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255,255,255,0.1);
            z-index: 200;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc6a);
            width: 0%;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>ðŸŽµ Sorting Visualizer</h2>

        <div class="control-row">
            <label>Algorithm</label>
            <select id="algorithm">
                <option value="bubble">Bubble Sort</option>
                <option value="selection">Selection Sort</option>
                <option value="insertion">Insertion Sort</option>
                <option value="merge">Merge Sort</option>
                <option value="quick">Quick Sort</option>
                <option value="heap">Heap Sort</option>
                <option value="radix">Radix Sort (LSD)</option>
                <option value="counting">Counting Sort</option>
                <option value="shell">Shell Sort</option>
                <option value="cocktail">Cocktail Shaker</option>
                <option value="comb">Comb Sort</option>
                <option value="gnome">Gnome Sort</option>
                <option value="oddeven">Odd-Even Sort</option>
                <option value="bitonic">Bitonic Sort</option>
            </select>
        </div>

        <div class="control-row">
            <label>Size</label>
            <input type="range" id="arraySize" min="16" max="512" value="128">
            <span class="value-label" id="sizeLabel">128</span>
        </div>

        <div class="control-row">
            <label>Speed</label>
            <input type="range" id="speed" min="0" max="100" value="85">
            <span class="value-label" id="speedLabel">Fast</span>
        </div>

        <div class="checkbox-row">
            <input type="checkbox" id="soundEnabled" checked>
            <label for="soundEnabled">ðŸ”Š Sound Effects</label>
        </div>

        <div class="checkbox-row">
            <input type="checkbox" id="rainbowMode">
            <label for="rainbowMode">ðŸŒˆ Rainbow Mode</label>
        </div>

        <div class="btn-row">
            <button class="btn btn-shuffle" id="shuffleBtn">Shuffle</button>
            <button class="btn btn-start" id="startBtn">â–¶ Start</button>
        </div>
    </div>

    <div class="stats">
        <h3>ðŸ“Š Statistics</h3>
        <div class="stat-item">
            <span class="label">Comparisons</span>
            <span class="value" id="comparisons">0</span>
        </div>
        <div class="stat-item">
            <span class="label">Array Accesses</span>
            <span class="value" id="accesses">0</span>
        </div>
        <div class="stat-item">
            <span class="label">Time</span>
            <span class="value" id="time">0.00s</span>
        </div>
        <div class="stat-item">
            <span class="label">Status</span>
            <span class="value" id="status">Ready</span>
        </div>
    </div>

    <div class="character" id="character">
        <img src="character.webp" alt="Character">
    </div>

    <div class="algo-info" id="algoInfo">
        <h4 id="algoName">Bubble Sort</h4>
        <div class="complexity">
            <span>Best: <strong id="bestTime">O(n)</strong></span>
            <span>Avg: <strong id="avgTime">O(nÂ²)</strong></span>
            <span>Worst: <strong id="worstTime">O(nÂ²)</strong></span>
        </div>
    </div>

    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>

    <script>
    // ==========================================
    // Sorting Algorithm Visualizer v2.0
    // ==========================================

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Resize canvas
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Algorithm info
    const algoData = {
        bubble: { name: 'Bubble Sort', best: 'O(n)', avg: 'O(nÂ²)', worst: 'O(nÂ²)' },
        selection: { name: 'Selection Sort', best: 'O(nÂ²)', avg: 'O(nÂ²)', worst: 'O(nÂ²)' },
        insertion: { name: 'Insertion Sort', best: 'O(n)', avg: 'O(nÂ²)', worst: 'O(nÂ²)' },
        merge: { name: 'Merge Sort', best: 'O(n log n)', avg: 'O(n log n)', worst: 'O(n log n)' },
        quick: { name: 'Quick Sort', best: 'O(n log n)', avg: 'O(n log n)', worst: 'O(nÂ²)' },
        heap: { name: 'Heap Sort', best: 'O(n log n)', avg: 'O(n log n)', worst: 'O(n log n)' },
        radix: { name: 'Radix Sort (LSD)', best: 'O(nk)', avg: 'O(nk)', worst: 'O(nk)' },
        counting: { name: 'Counting Sort', best: 'O(n+k)', avg: 'O(n+k)', worst: 'O(n+k)' },
        shell: { name: 'Shell Sort', best: 'O(n log n)', avg: 'O(n^1.3)', worst: 'O(nÂ²)' },
        cocktail: { name: 'Cocktail Shaker Sort', best: 'O(n)', avg: 'O(nÂ²)', worst: 'O(nÂ²)' },
        comb: { name: 'Comb Sort', best: 'O(n log n)', avg: 'O(nÂ²/2^p)', worst: 'O(nÂ²)' },
        gnome: { name: 'Gnome Sort', best: 'O(n)', avg: 'O(nÂ²)', worst: 'O(nÂ²)' },
        oddeven: { name: 'Odd-Even Sort', best: 'O(n)', avg: 'O(nÂ²)', worst: 'O(nÂ²)' },
        bitonic: { name: 'Bitonic Sort', best: 'O(logÂ²n)', avg: 'O(logÂ²n)', worst: 'O(logÂ²n)' }
    };

    // State
    let array = [];
    let sortedIndices = new Set();
    let highlightIndices = [];
    let highlightType = 'normal'; // 'comparing', 'swapping', 'sorted'
    let sorting = false;
    let stopped = false;
    let comparisons = 0;
    let accesses = 0;
    let startTime = 0;
    let sortedCount = 0;

    // Audio
    let audioCtx = null;
    let mainGain = null;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            mainGain = audioCtx.createGain();
            mainGain.gain.value = 0.15;
            mainGain.connect(audioCtx.destination);
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    function playTone(frequency, duration = 0.05, type = 'sine') {
        if (!document.getElementById('soundEnabled').checked || !audioCtx) return;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);

        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function valueToFreq(value, maxValue) {
        // Map to musical scale (C3 to C6)
        const minFreq = 130.81; // C3
        const maxFreq = 1046.50; // C6
        return minFreq + (value / maxValue) * (maxFreq - minFreq);
    }

    function playAccess(index) {
        if (!array[index]) return;
        const freq = valueToFreq(array[index], array.length);
        playTone(freq, 0.05, 'sine');
    }

    function playCompletion() {
        if (!document.getElementById('soundEnabled').checked || !audioCtx) return;

        const notes = [523.25, 659.25, 783.99, 1046.50];
        notes.forEach((freq, i) => {
            setTimeout(() => playTone(freq, 0.2, 'sine'), i * 100);
        });
    }

    // DOM
    const algorithmSelect = document.getElementById('algorithm');
    const arraySizeSlider = document.getElementById('arraySize');
    const speedSlider = document.getElementById('speed');
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const character = document.getElementById('character');

    // Generate array
    function generateArray() {
        const size = parseInt(arraySizeSlider.value);
        array = [];
        for (let i = 1; i <= size; i++) {
            array.push(i);
        }
        shuffle();
    }

    function shuffle() {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        sortedIndices.clear();
        highlightIndices = [];
        resetStats();
        render();
    }

    function resetStats() {
        comparisons = 0;
        accesses = 0;
        sortedCount = 0;
        document.getElementById('comparisons').textContent = '0';
        document.getElementById('accesses').textContent = '0';
        document.getElementById('time').textContent = '0.00s';
        document.getElementById('status').textContent = 'Ready';
        document.getElementById('progressFill').style.width = '0%';
    }

    function updateStats() {
        document.getElementById('comparisons').textContent = comparisons.toLocaleString();
        document.getElementById('accesses').textContent = accesses.toLocaleString();
        const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
        document.getElementById('time').textContent = elapsed + 's';
    }

    function updateProgress() {
        const progress = (sortedIndices.size / array.length) * 100;
        document.getElementById('progressFill').style.width = progress + '%';
    }

    function getDelay() {
        const speed = parseInt(speedSlider.value);
        // Exponential scale: 0 = 500ms, 100 = 0ms
        return Math.floor(500 * Math.pow(0.95, speed));
    }

    async function sleep(ms) {
        if (ms <= 0) return;
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Render
    function render() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const n = array.length;
        const barWidth = canvas.width / n;
        const maxVal = Math.max(...array);
        const rainbow = document.getElementById('rainbowMode').checked;

        for (let i = 0; i < n; i++) {
            const barHeight = (array[i] / maxVal) * (canvas.height - 50);
            const x = i * barWidth;
            const y = canvas.height - barHeight;

            let color;
            if (sortedIndices.has(i)) {
                color = '#00ff88';
            } else if (highlightIndices.includes(i)) {
                if (highlightType === 'comparing') {
                    color = '#ffff00';
                } else if (highlightType === 'swapping') {
                    color = '#ff4444';
                } else if (highlightType === 'pivot') {
                    color = '#ff00ff';
                } else {
                    color = '#00aaff';
                }
            } else if (rainbow) {
                const hue = (array[i] / maxVal) * 360;
                color = `hsl(${hue}, 100%, 50%)`;
            } else {
                const brightness = 30 + (array[i] / maxVal) * 70;
                color = `hsl(200, 80%, ${brightness}%)`;
            }

            ctx.fillStyle = color;

            if (barWidth > 2) {
                ctx.fillRect(x + 0.5, y, barWidth - 1, barHeight);
            } else {
                ctx.fillRect(x, y, barWidth, barHeight);
            }
        }
    }

    // Update algorithm info
    function updateAlgoInfo() {
        const algo = algorithmSelect.value;
        const info = algoData[algo];
        document.getElementById('algoName').textContent = info.name;
        document.getElementById('bestTime').textContent = info.best;
        document.getElementById('avgTime').textContent = info.avg;
        document.getElementById('worstTime').textContent = info.worst;
    }

    // ==========================================
    // Sorting Algorithms
    // ==========================================

    async function compare(i, j) {
        comparisons++;
        accesses += 2;
        highlightIndices = [i, j];
        highlightType = 'comparing';
        playAccess(i);
        render();
        updateStats();
        await sleep(getDelay());
        return array[i] - array[j];
    }

    async function swap(i, j) {
        accesses += 4;
        [array[i], array[j]] = [array[j], array[i]];
        highlightIndices = [i, j];
        highlightType = 'swapping';
        playAccess(i);
        playAccess(j);
        render();
        updateStats();
        await sleep(getDelay());
    }

    async function markSorted(indices) {
        indices.forEach(i => sortedIndices.add(i));
        updateProgress();
        render();
    }

    // Bubble Sort
    async function bubbleSort() {
        const n = array.length;
        for (let i = 0; i < n - 1; i++) {
            for (let j = 0; j < n - i - 1; j++) {
                if (stopped) return;
                if (await compare(j, j + 1) > 0) {
                    await swap(j, j + 1);
                }
            }
            await markSorted([n - i - 1]);
        }
        await markSorted([0]);
    }

    // Selection Sort
    async function selectionSort() {
        const n = array.length;
        for (let i = 0; i < n - 1; i++) {
            let minIdx = i;
            for (let j = i + 1; j < n; j++) {
                if (stopped) return;
                if (await compare(j, minIdx) < 0) {
                    minIdx = j;
                }
            }
            if (minIdx !== i) {
                await swap(i, minIdx);
            }
            await markSorted([i]);
        }
        await markSorted([n - 1]);
    }

    // Insertion Sort
    async function insertionSort() {
        const n = array.length;
        for (let i = 1; i < n; i++) {
            let j = i;
            while (j > 0) {
                if (stopped) return;
                if (await compare(j - 1, j) > 0) {
                    await swap(j - 1, j);
                    j--;
                } else {
                    break;
                }
            }
        }
    }

    // Merge Sort
    async function mergeSort() {
        await mergeSortHelper(0, array.length - 1);
    }

    async function mergeSortHelper(left, right) {
        if (left >= right || stopped) return;
        const mid = Math.floor((left + right) / 2);
        await mergeSortHelper(left, mid);
        await mergeSortHelper(mid + 1, right);
        await merge(left, mid, right);
    }

    async function merge(left, mid, right) {
        const temp = [];
        let i = left, j = mid + 1;

        while (i <= mid && j <= right) {
            if (stopped) return;
            comparisons++;
            accesses += 2;
            highlightIndices = [i, j];
            highlightType = 'comparing';
            playAccess(i);
            render();
            updateStats();
            await sleep(getDelay());

            if (array[i] <= array[j]) {
                temp.push(array[i++]);
            } else {
                temp.push(array[j++]);
            }
        }

        while (i <= mid) temp.push(array[i++]);
        while (j <= right) temp.push(array[j++]);

        for (let k = 0; k < temp.length; k++) {
            if (stopped) return;
            array[left + k] = temp[k];
            accesses++;
            highlightIndices = [left + k];
            highlightType = 'swapping';
            playAccess(left + k);
            render();
            updateStats();
            await sleep(getDelay() / 2);
        }
    }

    // Quick Sort
    async function quickSort() {
        await quickSortHelper(0, array.length - 1);
    }

    async function quickSortHelper(low, high) {
        if (low < high && !stopped) {
            const pi = await partition(low, high);
            await quickSortHelper(low, pi - 1);
            await quickSortHelper(pi + 1, high);
        }
    }

    async function partition(low, high) {
        const pivot = array[high];
        highlightIndices = [high];
        highlightType = 'pivot';
        render();

        let i = low - 1;
        for (let j = low; j < high; j++) {
            if (stopped) return low;
            comparisons++;
            accesses++;
            highlightIndices = [j, high];
            highlightType = 'comparing';
            playAccess(j);
            render();
            updateStats();
            await sleep(getDelay());

            if (array[j] < pivot) {
                i++;
                await swap(i, j);
            }
        }
        await swap(i + 1, high);
        await markSorted([i + 1]);
        return i + 1;
    }

    // Heap Sort
    async function heapSort() {
        const n = array.length;

        for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
            await heapify(n, i);
        }

        for (let i = n - 1; i > 0; i--) {
            if (stopped) return;
            await swap(0, i);
            await markSorted([i]);
            await heapify(i, 0);
        }
        await markSorted([0]);
    }

    async function heapify(n, i) {
        let largest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;

        if (left < n) {
            if (await compare(left, largest) > 0) {
                largest = left;
            }
        }

        if (right < n) {
            if (await compare(right, largest) > 0) {
                largest = right;
            }
        }

        if (largest !== i && !stopped) {
            await swap(i, largest);
            await heapify(n, largest);
        }
    }

    // Radix Sort (LSD)
    async function radixSort() {
        const max = Math.max(...array);
        for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
            await countingSortByDigit(exp);
        }
    }

    async function countingSortByDigit(exp) {
        const n = array.length;
        const output = new Array(n);
        const count = new Array(10).fill(0);

        for (let i = 0; i < n; i++) {
            if (stopped) return;
            const digit = Math.floor(array[i] / exp) % 10;
            count[digit]++;
            accesses++;
            highlightIndices = [i];
            highlightType = 'comparing';
            playAccess(i);
            render();
            updateStats();
            await sleep(getDelay() / 2);
        }

        for (let i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }

        for (let i = n - 1; i >= 0; i--) {
            if (stopped) return;
            const digit = Math.floor(array[i] / exp) % 10;
            output[count[digit] - 1] = array[i];
            count[digit]--;
        }

        for (let i = 0; i < n; i++) {
            if (stopped) return;
            array[i] = output[i];
            accesses++;
            highlightIndices = [i];
            highlightType = 'swapping';
            playAccess(i);
            render();
            updateStats();
            await sleep(getDelay() / 2);
        }
    }

    // Counting Sort
    async function countingSort() {
        const max = Math.max(...array);
        const count = new Array(max + 1).fill(0);
        const output = new Array(array.length);

        for (let i = 0; i < array.length; i++) {
            if (stopped) return;
            count[array[i]]++;
            accesses++;
            highlightIndices = [i];
            highlightType = 'comparing';
            playAccess(i);
            render();
            updateStats();
            await sleep(getDelay());
        }

        for (let i = 1; i <= max; i++) {
            count[i] += count[i - 1];
        }

        for (let i = array.length - 1; i >= 0; i--) {
            if (stopped) return;
            output[count[array[i]] - 1] = array[i];
            count[array[i]]--;
        }

        for (let i = 0; i < array.length; i++) {
            if (stopped) return;
            array[i] = output[i];
            accesses++;
            highlightIndices = [i];
            highlightType = 'swapping';
            playAccess(i);
            await markSorted([i]);
            render();
            updateStats();
            await sleep(getDelay());
        }
    }

    // Shell Sort
    async function shellSort() {
        const n = array.length;
        for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {
            for (let i = gap; i < n; i++) {
                let j = i;
                while (j >= gap) {
                    if (stopped) return;
                    if (await compare(j - gap, j) > 0) {
                        await swap(j - gap, j);
                        j -= gap;
                    } else {
                        break;
                    }
                }
            }
        }
    }

    // Cocktail Shaker Sort
    async function cocktailSort() {
        let swapped = true;
        let start = 0;
        let end = array.length - 1;

        while (swapped) {
            swapped = false;

            for (let i = start; i < end; i++) {
                if (stopped) return;
                if (await compare(i, i + 1) > 0) {
                    await swap(i, i + 1);
                    swapped = true;
                }
            }
            await markSorted([end]);
            end--;

            if (!swapped) break;
            swapped = false;

            for (let i = end - 1; i >= start; i--) {
                if (stopped) return;
                if (await compare(i, i + 1) > 0) {
                    await swap(i, i + 1);
                    swapped = true;
                }
            }
            await markSorted([start]);
            start++;
        }
    }

    // Comb Sort
    async function combSort() {
        const n = array.length;
        let gap = n;
        let shrink = 1.3;
        let sorted = false;

        while (!sorted) {
            gap = Math.floor(gap / shrink);
            if (gap <= 1) {
                gap = 1;
                sorted = true;
            }

            for (let i = 0; i + gap < n; i++) {
                if (stopped) return;
                if (await compare(i, i + gap) > 0) {
                    await swap(i, i + gap);
                    sorted = false;
                }
            }
        }
    }

    // Gnome Sort
    async function gnomeSort() {
        let i = 0;
        while (i < array.length) {
            if (stopped) return;
            if (i === 0 || await compare(i - 1, i) <= 0) {
                i++;
            } else {
                await swap(i - 1, i);
                i--;
            }
        }
    }

    // Odd-Even Sort
    async function oddEvenSort() {
        let sorted = false;
        while (!sorted) {
            sorted = true;

            for (let i = 1; i < array.length - 1; i += 2) {
                if (stopped) return;
                if (await compare(i, i + 1) > 0) {
                    await swap(i, i + 1);
                    sorted = false;
                }
            }

            for (let i = 0; i < array.length - 1; i += 2) {
                if (stopped) return;
                if (await compare(i, i + 1) > 0) {
                    await swap(i, i + 1);
                    sorted = false;
                }
            }
        }
    }

    // Bitonic Sort
    async function bitonicSort() {
        const n = array.length;
        // Pad to power of 2
        const pow2 = Math.pow(2, Math.ceil(Math.log2(n)));
        while (array.length < pow2) {
            array.push(pow2 + 1);
        }
        await bitonicSortHelper(0, array.length, true);
        array.length = n;
    }

    async function bitonicSortHelper(low, cnt, dir) {
        if (cnt > 1 && !stopped) {
            const k = Math.floor(cnt / 2);
            await bitonicSortHelper(low, k, true);
            await bitonicSortHelper(low + k, k, false);
            await bitonicMerge(low, cnt, dir);
        }
    }

    async function bitonicMerge(low, cnt, dir) {
        if (cnt > 1 && !stopped) {
            const k = Math.floor(cnt / 2);
            for (let i = low; i < low + k; i++) {
                if (stopped) return;
                const cmp = await compare(i, i + k);
                if ((dir && cmp > 0) || (!dir && cmp < 0)) {
                    await swap(i, i + k);
                }
            }
            await bitonicMerge(low, k, dir);
            await bitonicMerge(low + k, k, dir);
        }
    }

    // Mark all sorted animation
    async function markAllSorted() {
        for (let i = 0; i < array.length; i++) {
            sortedIndices.add(i);
            playAccess(i);
            render();
            updateProgress();
            await sleep(5);
        }
        playCompletion();
    }

    // Main sort function
    async function startSort() {
        if (sorting) return;

        initAudio();
        sorting = true;
        stopped = false;
        sortedIndices.clear();
        resetStats();
        startTime = performance.now();
        document.getElementById('status').textContent = 'Sorting...';
        startBtn.disabled = true;
        shuffleBtn.disabled = true;
        startBtn.textContent = 'â¹ Stop';
        startBtn.classList.remove('btn-start');
        startBtn.classList.add('btn-stop');
        character.classList.add('excited');

        const algorithm = algorithmSelect.value;

        try {
            switch (algorithm) {
                case 'bubble': await bubbleSort(); break;
                case 'selection': await selectionSort(); break;
                case 'insertion': await insertionSort(); break;
                case 'merge': await mergeSort(); break;
                case 'quick': await quickSort(); break;
                case 'heap': await heapSort(); break;
                case 'radix': await radixSort(); break;
                case 'counting': await countingSort(); break;
                case 'shell': await shellSort(); break;
                case 'cocktail': await cocktailSort(); break;
                case 'comb': await combSort(); break;
                case 'gnome': await gnomeSort(); break;
                case 'oddeven': await oddEvenSort(); break;
                case 'bitonic': await bitonicSort(); break;
            }

            if (!stopped) {
                await markAllSorted();
                document.getElementById('status').textContent = 'Complete!';
            } else {
                document.getElementById('status').textContent = 'Stopped';
            }
        } catch (e) {
            console.error(e);
        }

        highlightIndices = [];
        render();
        sorting = false;
        startBtn.disabled = false;
        shuffleBtn.disabled = false;
        startBtn.textContent = 'â–¶ Start';
        startBtn.classList.remove('btn-stop');
        startBtn.classList.add('btn-start');
        character.classList.remove('excited');
    }

    function stopSort() {
        stopped = true;
    }

    // Event Listeners
    startBtn.addEventListener('click', () => {
        if (sorting) {
            stopSort();
        } else {
            startSort();
        }
    });

    shuffleBtn.addEventListener('click', () => {
        if (!sorting) shuffle();
    });

    algorithmSelect.addEventListener('change', updateAlgoInfo);

    arraySizeSlider.addEventListener('input', () => {
        document.getElementById('sizeLabel').textContent = arraySizeSlider.value;
        if (!sorting) generateArray();
    });

    speedSlider.addEventListener('input', () => {
        const val = parseInt(speedSlider.value);
        let label = 'Medium';
        if (val < 30) label = 'Slow';
        else if (val < 60) label = 'Medium';
        else if (val < 90) label = 'Fast';
        else label = 'Ultra';
        document.getElementById('speedLabel').textContent = label;
    });

    // Init
    generateArray();
    updateAlgoInfo();
    render();
    </script>
</body>
</html>
